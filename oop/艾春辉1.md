## oop面向对象
- 面向对象编程
     - 基础
     - 公有私有
     - 继承
     -组合
- 魔法函数
     - 魔法函数概述
     - 构造类魔法函数
     - 运算类魔法函数
##面向对象概述
-  oop思想
     - 接受思想，任务的构成----模型
- 几个名词
     - OO ：面向对象
     - OOA：面向对象分析
     - OOD：面向对象设计
     - OOI：面向对象实现
     - OOP：面向对象编程
     - A -> D -->I 面向对象实现过程
##类和对象的概念
   - 类：抽象名词，代表一个集合，共性事物
   - 对象：具体事物，单个个体
   - 类和对象
   - 一个具象，代表一类事物的某一个个体
   - 一个是抽象，代表一大类事物
- 类中的内容
   - 表明事物的特征，叫做属性（变量）
   - 表明事物功能或者动作， 称为成员方法（函数）
## 类的基本实现
- 类的命名
    - 尊守变量命名的规范
    - 大驼峰
    - 尽量避开和系统命名类似的命名
- 类的使用
  - class声明
  - 用None给不确实值赋值
  - 推荐在函数末尾用return
  - 实例化 变量 = 类名（）
- 访问对象成员
  - 使用点操作符
  - 可以通过内置变量检查类和对象的所有成员
       - 对象成员：obj.__dict__
       - 类的成员: class_name.__dict__   
## 类和对象的成员分析
- 类和对象都可以存储成员，成员归类所有，也可以归对象所有
- 类存储成员时使用的是与类关联的一个对象
- 独享成员是存储在当前对象中
- 对象访问一个成员时，如果对象中，没有该成员，尝试访问类中的同名成员，如果对象中有此成员，一定使用对象中的成员
- id可以核查一个变量是否和另一个变量一模一样
- 在没有赋值的情况下，用的是同一个对象
- 创建对象时候，类的成员不会放入对象中，而是得到一个空对象，没有成员
- 通过对象对类中成员重新赋值或者通过对象添加成员，对应对象成员会保存在对象中而不会修改类成员
## 关于self
- self在对象方法中表示当前对象本身，如果通过对象调用一个方法，那么该对象会自动传入当前方法的第一个参数中，约定俗成的是用self，但是你用其他的也行
- 方法中有self的方法成为非绑定类方法，可以通过对象访问，系统默认把对象当成self传入，没有self的方法是绑定类方法，只能通过类来访问
- 使用类访问绑定类的方法时，如果类方法中需要访问当前类的成员，可以通过__class__成员名来访问
## 面对对象三大特性
- 封装
   - 对对象成员的进行访问限制
   - 三个级别
       - 公开 public
       - 保护 protected
       - 私有 private
       - 这些不是关键字
   - 私有
       - 私有成员是最高级别的封装，只能在当前类或对象中访问
       - 在成员变量面前添加两个下划线即可
            例子: __age = 18
       - python私有不是真的私有，只是一种改名策略（安全考虑），可以使用__dict__显示真名字
   - 受保护的封装protected
       - 类和子类都可以进访问但是外部不可以
       - 成员名字在前面加下划线
   - 公共的，共有的
       - 对成员没有限制
   - 清楚界限
## 继承
- 一个类获得另一个类中成员属性和成员方法、
- 作用：减少代码，增加代码的复用性，表示类与类之间关系
- 继承的特征
    - 所有的子类都继承自父类
    - 子类继承父类除私有成员之外的所有成员和函数
    - 父类的成员不是直接赋值到子类中，而是子类通过引用关系直接引用的
    - 子类中成员子类优先使用
    - 子类如果想扩充父类的成员，可以在定义新方法的同时调用父类的成员，父类.父类名，或者super().父类成员 
    - 子类可以冒充父类，父类不可以冒充子类
- 继承变量函数的查找顺序问题
    - 优先查找自己的，后面才是父类的
    - 构造函数如果本类无定义，则自动查找调用父类构造函数
- 构造函数
  - 如果子类构造函数没有，那么按照父类构造函数的形式进行4
- super
  - super‘不是关键字，而是一个类
  - super的作用是调用MRO中的第一个类
  - super与父类没有任何实质性关系
- 单继承和多继承
  - 单继承，只能继承一个类
  - 多继承，继承多个类
  - 优缺点
     - 传递有序逻辑清晰，简单，安全
     - 功能不能 无限扩展
     - 类功能扩展方便
     - 继承关系混乱
- 菱形继承、砖石继承
  - 多个子类继承同一个父类，这些子类被同一个类继承
  - 多继承的MRO
     - mro是多继承中，保存多继承的顺序关系
- 构造函数
  - 在对象实例化时候，系统自动调用的一个函数叫构造函数，__init__(self)
  - 如果子类没有写构造函数，则自动向上查找，直到找到位置
  - 构造函数一定要有
  - 扩展构造函数：通过父类名调用父类构造函数，再添加一些功能
## 多态      
  - 就是指同一个对象在不同情况下有不同的状态
  - 多态不是语法，而是一种设计思想
  - 多态：一种调用方式，不同执行效果
  - 多态：同一事物不同形态，可以理解为物理变化，为这个事物添加一些功能
  - 使用多继承语法实现minxin
  - 必须表示功能单一性，如果多个功能，则是多个minxin
  - 不能依赖子类实现
  - 优点
      - 可以在不对类进行任何修改下，扩展
      - 可以方便的组织和维护不同功能组件的划分
      - 可以根据需要任意调整功能类的组合
      - 可以避免创建很多新的类，导致类的继承好混乱
## 类相关函数
- issubclass 判断两个类之间的父子关系
- isinstance 检测是不是类的一个实例
- hasattr 检测一个对象是否有成员
- getattr：
- setattr：
- dir：接受对象的成员列表
## 类的成员描述符号（属性）
- 类的成员描述父为了在类中对类的成员属性进行修改的一种方式
- 个体：获取属性
- sel 修改或者添加属性
- delete 删除属性操作
- 使用property函数 property(fget,fset,fdel,doc)
- 无论那种修饰符都是为了对成员属性进行相应操作
- 修饰符：适用于当前类里面使用控制相应的属性
## 类的内置属性
- __dict__:以字典方式显示类的成员组成
- __doc__:函数进行显示类的文档信息
- __name__:获取类的名称，如果在模块的使用，获取模块名称
- __base__: 获取某个子类的所有父类
## 类的常用魔法方法
- 就是不需要人为调用，自动触发的
- 方法名字前后都有下划线
- 操作类
    - __init__: 构造函数
    - __new__: 对象实例化方法，一般不需要你使用
    - __call__: 对象当函数使用时触发
    - __str__: 当实例当对象使用的是触发
    - __repr__: 返回字符串，和__str)__没有太大区别
- 描述符
    - __set__
    - __get__
    - __delete__
- 属性操作类
    - __getattr__:访问一个不存在属性触发
    - __setattr__： 对成员属性设置触发
         - self欧诺个来获取当前对象
         - 被设置的属性名称，以字符串形式触发
         - 需要对属性设置的值
         作用：在属性设置时进行验证或者更改
         - 注意：在该方法中不能对属性直接进行修改，否则死循环
- 运算分类相关魔术方法
    - __gt__：进行大于判断触发的函数
## 类和对象的三种方法
- 实例方法 
    - 需要实例话才能使用，使用过程中可能需要截止对象的其他对象方法完成
- 静态方法
    - 不需要实例化，通过类进行访问
- 类方法
    - 不需要实例化，没有参数
## 抽象类
- 抽象方法： 没有具体实现内容的方法成为抽象方法
- 抽象方法的主要意义是为了规范子类的行为和接口
- 抽象类的使用abc模块
- 抽象类：包含抽象方法的叫抽象类
- 抽象类的使用
   - 抽象类的使用可以包含抽象方法，也可以包含具体方法
   - 抽象类可以有方法也可以有属性
   - 抽象类不允许实例化
   - 必须继承才能使用，且继承的子类必须实现所有继承来的抽象方法
   - 设定类的标准，便于开发的时候具有统一的规范
## 自定义类
- 类是类定义和方法组装集合
         

 
  